from pathlib import Path

import numpy as np
import tensorflow as tf
from matplotlib import pyplot as plt

# Assume CIFAR-10 classes if needed for titles, or pass them
CIFAR10_CLASSES = [
    "airplane",
    "automobile",
    "bird",
    "cat",
    "deer",
    "dog",
    "frog",
    "horse",
    "ship",
    "truck",
]


def plot_conditional_examples(
    generators: list,  # List of generator models
    fixed_noise: tf.Tensor,  # Shape: (num_examples, latent_dim)
    fixed_conditions: tf.Tensor,  # Shape: (num_examples, condition_dim), one-hot encoded
    condition_labels: list,  # List of readable labels for conditions (e.g., class names or numbers)
    epoch: int,
    dir_name: Path,
    latent_dim: int,  # Needed if generating new noise inside (though fixed is better)
    samples_subfolder: str = "conditional_examples",
    real_examples: np.ndarray = None,  # Optional: Real examples corresponding to conditions (N, H, W, C)
    save: bool = True,
    show: bool = False,
) -> None:
    """
    Plots a grid comparing outputs of multiple generators for fixed conditions.
    Layout: Rows = Generators (+ optional Real), Columns = Conditions.
    """
    num_generators = len(generators)
    num_examples = fixed_noise.shape[0]  # Should match fixed_conditions.shape[0]

    if num_examples != len(condition_labels):
        raise ValueError(
            "Number of fixed noise/conditions must match number of condition labels."
        )

    n_rows = num_generators
    plot_real = real_examples is not None
    if plot_real:
        if real_examples.shape[0] != num_examples:
            print(
                f"Warning: Number of real examples ({real_examples.shape[0]}) doesn't match "
                f"number of conditions ({num_examples}). Real examples might not align."
            )
        n_rows += 1  # Add a row for real examples

    n_cols = num_examples

    fig, axes = plt.subplots(
        nrows=n_rows, ncols=n_cols, figsize=(n_cols * 1.5, n_rows * 1.5)
    )
    # Ensure axes is always a 2D array
    if n_rows == 1 and n_cols == 1:
        axes = np.array([[axes]])
    elif n_rows == 1:
        axes = axes.reshape(1, n_cols)
    elif n_cols == 1:
        axes = axes.reshape(n_rows, 1)

    fig.suptitle(f"Generated Examples - Epoch: {epoch+1}", fontsize=16, y=1.02)

    generated_images_all_gens = []
    for gen_nr, generator in enumerate(generators):
        # Generate images for all conditions for this generator
        # Ensure inputs are in the expected list format [noise, condition]
        generated_batch = generator([fixed_noise, fixed_conditions], training=False)
        generated_images_all_gens.append(generated_batch.numpy())

    for r in range(n_rows):
        for c in range(n_cols):
            ax = axes[r, c]
            img = None
            title = ""

            if plot_real and r == num_generators:  # Last row is real examples
                img = real_examples[c]
                title = f"Real ({condition_labels[c]})"
                gen_source = "Real"
            else:  # Rows for generators
                gen_nr = r
                # Select the c-th image generated by the r-th generator
                img = generated_images_all_gens[gen_nr][c]
                title = f"Gen {gen_nr} ({condition_labels[c]})"
                gen_source = f"Gen_{gen_nr}"

            # Denormalize image from [-1, 1] to [0, 1]
            img_display = (np.clip(img, -1.0, 1.0) + 1.0) / 2.0

            # Determine cmap based on channels
            if img_display.shape[-1] == 1:
                cmap = "gray"
                img_display = np.squeeze(
                    img_display, axis=-1
                )  # Remove channel dim for grayscale imshow
            elif img_display.shape[-1] == 3:
                cmap = None  # imshow handles RGB automatically
            else:
                # Handle unexpected channel count if necessary
                print(
                    f"Warning: Image from {gen_source} for cond {condition_labels[c]} has shape {img.shape}. Plotting first channel."
                )
                cmap = "gray"
                img_display = img_display[..., 0]

            ax.imshow(img_display, cmap=cmap)
            ax.set_title(title, fontsize=8)
            ax.axis("off")

    plt.tight_layout(rect=[0, 0.03, 1, 0.98])  # Adjust layout

    if save:
        save_dir = Path(dir_name) / samples_subfolder
        save_dir.mkdir(exist_ok=True, parents=True)
        save_path = save_dir / f"epoch_{(epoch + 1):04d}.png"
        plt.savefig(save_path, dpi=150, format="png")  # Lower dpi slightly if needed
        print(f"Saved example plot to {save_path}")
        plt.close(fig)  # Close figure to free memory
    if show:
        plt.show()


class CMADGANMonitor(tf.keras.callbacks.Callback):
    """Callback to plot conditional generated examples during training."""

    def __init__(
        self,
        latent_dim: int,
        n_classes: int,  # Number of classes in the dataset
        dir_name: Path = Path("Model"),
        samples_subfolder: str = "conditional_examples",
        generate_after_epochs: int = 10,
        num_examples_per_class: int = 1,  # How many examples of each class to generate
        class_labels: list = None,  # Optional: List of readable class names
        real_dataset: tf.data.Dataset = None,  # Optional: Dataset to sample real examples from
    ) -> None:
        """
        Parameters
        ----------
        latent_dim : int
            Dimensionality of the latent space.
        n_classes : int
            Number of classes in the dataset.
        dir_name : Path, optional
            Base directory to save the generated images. Defaults to 'Model'.
        samples_subfolder : str, optional
            Subfolder within dir_name for the images. Defaults to 'conditional_examples'.
        generate_after_epochs : int, optional
            Frequency (in epochs) to generate and save images. Defaults to 10.
        num_examples_per_class : int, optional
            Number of fixed examples to generate for each class. Defaults to 1.
        class_labels : list, optional
            List of string names for each class index (0 to n_classes-1). Defaults to using indices.
        real_dataset : tf.data.Dataset, optional
            A tf.data.Dataset yielding (image, label_one_hot) tuples to sample real examples from.
            If provided, real examples corresponding to the generated conditions will be plotted.
        """
        super().__init__()

        self.latent_dim = latent_dim
        self.n_classes = n_classes
        self.dir_name = Path(dir_name)
        self.samples_subfolder = samples_subfolder
        self.generate_after_epochs = generate_after_epochs
        self.num_examples_per_class = num_examples_per_class
        self.total_examples = self.n_classes * self.num_examples_per_class

        # Create fixed noise and condition vectors
        self.fixed_noise = tf.random.normal(
            shape=(self.total_examples, self.latent_dim)
        )

        # Create condition labels (integers first)
        fixed_conditions_int = np.repeat(
            np.arange(self.n_classes), self.num_examples_per_class
        )
        self.fixed_conditions = tf.one_hot(fixed_conditions_int, depth=self.n_classes)

        # Prepare readable labels for plots
        if class_labels:
            if len(class_labels) != self.n_classes:
                raise ValueError(
                    f"Provided class_labels length ({len(class_labels)}) != n_classes ({self.n_classes})"
                )
            # Repeat labels if num_examples_per_class > 1 (less ideal for plotting titles)
            self.condition_plot_labels = [class_labels[i] for i in fixed_conditions_int]
        else:
            self.condition_plot_labels = [str(i) for i in fixed_conditions_int]

        # Prepare fixed real examples (if dataset provided)
        self.real_examples_fixed = None
        if real_dataset:
            self.real_examples_fixed = self._get_fixed_real_examples(
                real_dataset, fixed_conditions_int
            )

    def _get_fixed_real_examples(self, dataset, target_labels_int):
        """Samples one real example for each target label."""
        print("Sampling fixed real examples for plotting...")
        real_examples = {}  # Dict to store one example per class index
        count = 0
        target_set = set(target_labels_int)  # Unique labels we need
        num_needed = (
            len(target_set) * self.num_examples_per_class
        )  # Total needed across all requests

        # Iterate through the dataset to find examples
        # This might be slow if the dataset is large and not shuffled ideally
        # Assumes dataset yields (image, one_hot_label) or similar structure
        for img_batch, label_batch_one_hot in (
            dataset.unbatch().shuffle(1000).take(num_needed * 5)
        ):  # Take more than needed
            label_int = tf.argmax(label_batch_one_hot).numpy()
            if label_int in target_set:
                # If we need multiple examples per class, store them in lists
                if label_int not in real_examples:
                    real_examples[label_int] = []
                if len(real_examples[label_int]) < self.num_examples_per_class:
                    real_examples[label_int].append(img_batch.numpy())
                    count += 1
                    # Check if we have enough examples overall
                    if count >= num_needed:
                        break

        if count < num_needed:
            print(
                f"Warning: Could only find {count}/{num_needed} matching real examples."
            )

        # Arrange examples in the same order as target_labels_int
        final_examples = []
        current_class_counts = {i: 0 for i in range(self.n_classes)}
        for target_label in target_labels_int:
            if target_label in real_examples and current_class_counts[
                target_label
            ] < len(real_examples[target_label]):
                final_examples.append(
                    real_examples[target_label][current_class_counts[target_label]]
                )
                current_class_counts[target_label] += 1
            else:
                # Add a placeholder (e.g., black image) if no example was found
                print(
                    f"Warning: Missing real example for class {target_label}. Using placeholder."
                )
                # Get expected shape from found examples or default
                if final_examples:
                    h, w, c = final_examples[0].shape[-3:]  # Assuming N, H, W, C
                else:  # Guess shape (needs refinement based on dataset)
                    h, w, c = (32, 32, 3) if self.n_classes == 10 else (28, 28, 1)
                final_examples.append(
                    np.zeros((h, w, c), dtype=np.float32) - 1.0
                )  # Black image in [-1, 1] range

        return np.array(final_examples) if final_examples else None

    def on_epoch_end(self, epoch: int, logs: dict = None) -> None:
        """Generates and saves images at specified epoch intervals."""
        # Check if the model structure is compatible
        if not hasattr(self.model, "generators") or not isinstance(
            self.model.generators, list
        ):
            print("Monitor Error: Model does not have a 'generators' list attribute.")
            return
        if not self.model.generators:
            print("Monitor Error: Model 'generators' list is empty.")
            return

        if (epoch + 1) % self.generate_after_epochs == 0 or (epoch + 1) == getattr(
            self.model, "stop_training", False
        ):  # Also generate on last epoch if possible
            print(f"\nEpoch {epoch+1}: Generating conditional example plots...")
            try:
                plot_conditional_examples(
                    generators=self.model.generators,
                    fixed_noise=self.fixed_noise,
                    fixed_conditions=self.fixed_conditions,
                    condition_labels=self.condition_plot_labels,
                    epoch=epoch,
                    dir_name=self.dir_name,
                    latent_dim=self.latent_dim,  # Pass latent_dim
                    samples_subfolder=self.samples_subfolder,
                    real_examples=self.real_examples_fixed,  # Pass fixed real examples
                    save=True,
                    show=False,  # Typically don't show during training
                )
            except Exception as e:
                print(f"\nError generating plot in ConditionalGANMonitor: {e}")
                # import traceback
                # traceback.print_exc() # Uncomment for detailed traceback
