import json
from pathlib import Path
from typing import Callable, Tuple

import numpy as np
import tensorflow as tf
from tqdm import tqdm
from utils.logging import setup_logger


class DatasetCreator:
    """
    Creates a stratified dataset for training a classifier.
    Train data:
        Depending on the dicts (number_of_generated_images_per_class, number_of_real_images_per_class),
        the training data may contain generated training data. E.g., images generated by a GAN architecture.
    Test data:
        The test data will NOT contain any generated images, as it shall serve as a ground truth for comparing classifiers.

    ENTRY POINT:
        After instantiating, call the function create_dataset. This will return a tuple of 4:
        tuple(x_train, y_train, x_test, y_test)
    """

    def __init__(
        self,
        dataset: str,
        experiment_folder_path: str,
        tf_dataset_load_func: Callable,
        number_of_generated_images_per_class: dict,
        number_of_real_images_per_class: dict,
        seed: int = 42,
    ):
        self.dataset = dataset
        self.experiment_folder_path = Path(experiment_folder_path)
        self.generated_images_folder = self.experiment_folder_path / "generated_images"
        self.tf_dataset_load_func = tf_dataset_load_func
        self.number_of_generated_images_per_class = number_of_generated_images_per_class
        self.number_of_real_images_per_class = number_of_real_images_per_class
        self.seed = seed

        self.created_images_labels_file = self.experiment_folder_path / "labels.json"
        self.created_images_certainties_file = (
            self.experiment_folder_path / "certainties.json"
        )

        with open(self.created_images_labels_file, "r") as f:
            self.gen_labels = json.load(f)

        self.logger = setup_logger(name="DatasetCreator")

    def create_dataset(
        self, shuffle=True
    ) -> Tuple[np.array, np.array, np.array, np.array]:
        """
        Creates the training and test datasets.
        Returns:
            Tuple[tf.data.Dataset, tf.data.Dataset, tf.data.Dataset, tf.data.Dataset]:
                (x_train, y_train, x_test, y_test)
        """
        (
            (real_train_x, real_train_y),
            (
                real_test_x,
                real_test_y,
            ),
        ) = self.tf_dataset_load_func()
        real_train_x = real_train_x / 255
        real_test_x = real_test_x / 255

        gen_train_x, gen_train_y = self._load_and_preprocess_generated_data()

        real_rdx = self._get_stratified_index(
            n_images_by_class=self.number_of_real_images_per_class, labels=real_train_y
        )

        gen_rdx = self._get_stratified_index(
            n_images_by_class=self.number_of_generated_images_per_class,
            labels=gen_train_y,
        )

        ss_real_train_x = real_train_x[real_rdx]
        ss_gen_train_x = gen_train_x[gen_rdx]
        ss_real_train_y = real_train_y[real_rdx]
        ss_gen_train_y = gen_train_y[gen_rdx]

        if self.dataset != "cifar10":
            ss_real_train_x = tf.expand_dims(ss_real_train_x, axis=-1)

        merged_train_x = np.concatenate([ss_gen_train_x, ss_real_train_x])
        merged_train_y = np.concatenate([ss_gen_train_y, ss_real_train_y])

        if shuffle:
            rng = np.random.default_rng(self.seed)
            rdx = rng.permutation(len(merged_train_x))
            merged_train_x = merged_train_x[rdx]
            merged_train_y = merged_train_y[rdx]

        return merged_train_x, merged_train_y, real_test_x, real_test_y

    def _get_stratified_index(
        self, n_images_by_class: dict, labels: np.array
    ) -> np.array:
        """
        Create a list of indexes for stratified sub-selection of samples from a dataset.

        Parameters:
            n_images_by_class (dict): A dictionary mapping class label to the number of samples to select,
                                      e.g., {i: 5000 for i in range(10)}.
            labels (np.ndarray): A 1D numpy array of class labels corresponding to each sample in the dataset.
            seed (int): Random seed for reproducibility.

        Returns:
            List[int]: A list of indexes that can be used to subselect samples from the data.
        """
        selected_indexes = []

        for label, count in n_images_by_class.items():
            label_indexes = np.where(labels == label)[0]

            if len(label_indexes) < count:
                raise ValueError(
                    f"Not enough samples for class {label}: requested {count}, available {len(label_indexes)}"
                )

            selected_indexes.append(label_indexes[:count])

        selected_indexes = np.concatenate(selected_indexes)

        return selected_indexes.tolist()

    def _load_and_preprocess_generated_data(self) -> Tuple[np.ndarray, np.ndarray]:
        """
        Loads generated images (png files) from self.generated_images_folder using labels
        from labels.json. Decodes and scales images to [0,1]. Supports colored images (3 channels) and grayscale (1 channel).

        Returns:
            Tuple[np.ndarray, np.ndarray]: Arrays of images and corresponding labels.
        """
        images = []
        labels = []

        total_files = len(self.gen_labels)

        n_channels = 1 if self.dataset != "cifar10" else 3

        # Process images with a tqdm progress bar.
        for filename, class_label in tqdm(
            self.gen_labels.items(), total=total_files, desc="Processing images"
        ):
            image_path: Path = self.generated_images_folder / filename
            if not image_path.exists():
                self.logger.warning(f"{image_path} does not exist. Skipping.")
                continue

            img_raw = tf.io.read_file(str(image_path))
            img = tf.image.decode_png(img_raw, channels=n_channels)
            img = tf.image.convert_image_dtype(img, tf.float32)

            images.append(img)
            labels.append(class_label)

        if not images:
            raise ValueError(
                "No generated images were loaded. Please check the folder and labels.json."
            )

        return np.array(images), np.array(labels)
